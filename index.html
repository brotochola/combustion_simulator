<!DOCTYPE html>
<html>

<head>
    <style>
        #canvas {
            background-color: black;
        }

        #info {
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            margin: 10px;
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div id="info"></div>
    <script>
        // https://codepen.io/davepvm/pen/Hhstl
        // Particle class representing each molecule
        class Particle {
            constructor(x, y, substance, temperature) {
                this.nearParticles = []
                this.x = x; // x-coordinate
                this.y = y; // y-coordinate
                this.substance = substance || 'wood'; // substance of the particle
                this.heatCapacityAccordingToSubstance()
                this.massAccordingToSubstance()
                this.energyContainedAccordingToEinstein()
                this.thermalConductivityAccordingToSubstance()
                this.burningTemperatureAccordingToSubstance()
                // this.heat = 0; // heat being applied to the particle
                this.temperature = temperature || 20;

                this.velocity = { x: 0, y: 0 }; // velocity of the particle
                // this.gravity = 0; // gravity affecting the particle
                this.acceleration = { x: 0, y: 0 }
                this.onFire = false; // flag indicating if the particle is on fire
            }
            burningTemperatureAccordingToSubstance() {
                if (this.substance == "wood") this.burningTemperature = 250

            }
            thermalConductivityAccordingToSubstance() {
                if (this.substance == "wood") this.thermalConductivity = 0.000025
            }
            energyContainedAccordingToEinstein() {
                //energy contained in joules
                // if (this.substance == "wood") this.energyContained = this.mass * 10000
                if (this.substance == "wood") this.energyContained = this.mass * 1000000000

            }
            heatCapacityAccordingToSubstance() {
                //energy in joules to raise this particles (1mm3) 1 degree C
                if (this.substance == "wood") this.heatCapacity = 0.001025
            }
            massAccordingToSubstance() {
                //mass in grams
                //each particle is 1mm3
                //0,0005gr / mm3

                if (this.substance == "wood") this.mass = 0.0005
            }
            applyHeat(joules) {
                this.temperature += joules * this.heatCapacity
            }


            burn() {
                //when it burns, it converts to another substance
                //and releases heat
                this.onFire = true
                const amountOfEnergyToTransmitToClosestParticles = 0.2
                const amountOfEnergyToTransmitTo2ndLevelParticles = 0.066


                for (const p of this.nearParticles) {

                    //the amount of energy to be released goes to other particles
                    //according to the distance they get more or less

                    //apply 10% of the energy to nearParticles
                    const howMuchEnergy = (this.energyContained * amountOfEnergyToTransmitToClosestParticles) / this.nearParticles.length
                    p.applyHeat(howMuchEnergy);
                    this.energyContained -= howMuchEnergy


                    let tempArrayOfNearPArticlesLvl2 = []
                    for (const p2 of p.nearParticles) {
                        if (p2 == p) continue
                        tempArrayOfNearPArticlesLvl2.push(p2)
                    }


                    //apply 5% of the energy to particles that are near of the near ones
                    let howMuchEnergy2 = (this.energyContained * amountOfEnergyToTransmitTo2ndLevelParticles) / tempArrayOfNearPArticlesLvl2.length
                    for (const p2 of tempArrayOfNearPArticlesLvl2) {
                        p2.applyHeat(howMuchEnergy2);
                        this.energyContained -= howMuchEnergy2

                    }




                }
            }

            transferTemperatureToSurroundingParticles() {
                for (const particle of this.particles) {
                    if (particle !== this) {

                        const distance = Math.sqrt(
                            Math.pow(this.x - particle.x, 2) + Math.pow(this.y - particle.y, 2)
                        );

                        const avg = (this.temperature + particle.temperature) / 2
                        const avgThermalConductivity = (this.thermalConductivity + particle.thermalConductivity) / 2
                        if (this.temperature > particle.temperature) {
                            this.temperature -= (avg / distance) * avgThermalConductivity
                            particle.temperature += (avg / distance) * avgThermalConductivity
                        } else {
                            this.temperature += (avg / distance) * avgThermalConductivity
                            particle.temperature -= (avg / distance) * avgThermalConductivity
                        }


                    }
                }
            }

            update(particles) {
                // Update the particle's position and velocity
                this.x += this.velocity.x;
                this.y += this.velocity.y;

                // Apply gravity
                this.velocity.y += this.acceleration.y;
                this.velocity.x += this.acceleration.x;


                if (this.temperature > this.burningTemperature) {
                    this.burn()
                }

                this.transferTemperatureToSurroundingParticles()

                // for (const particle of particles) {
                //     if (particle !== this) {
                //         const distance = Math.sqrt(
                //             Math.pow(this.x - particle.x, 2) + Math.pow(this.y - particle.y, 2)
                //         );
                //         const energyTransfer = Math.min(this.heat / distance, this.heat);
                //         // particle.heat += energyTransfer;
                //         particle.applyHeat(energyTransfer);
                //         this.applyHeat(energyTransfer)
                //     }
                // }

            }



            render(context) {
                // Render the particle on the canvas
                if (this.onFire) {
                    // Render fire effect when the particle is on fire
                    const radius = 5 + Math.random() * 5;
                    const intensity = 60 + Math.random() * 60;
                    const gradient = context.createRadialGradient(this.x, this.y, 0, this.x, this.y, radius);
                    gradient.addColorStop(0, `rgba(255, ${intensity}, 0, 0.1)`);
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    context.fillStyle = gradient;
                    context.fillRect(this.x - radius, this.y - radius, radius * 2, radius * 2);
                } else {
                    // Render regular particle
                    let r = this.temperature * 2
                    let g = 30
                    let b = 30
                    context.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
                    context.fillRect(this.x, this.y, 1, 1);
                }
            }
        }

        // Particle System class
        class ParticleSystem {
            constructor(canvasId, width, height) {
                this.canvas = document.getElementById(canvasId);
                this.context = this.canvas.getContext('2d');
                this.canvas.width = width;
                this.canvas.height = height;
                this.particles = []; // array to hold all particles

                // // Add event listener to resize canvas when window size changes
                // window.addEventListener('resize', () => {
                //     this.canvas.width = width;
                //     this.canvas.height = height;
                // });

                // Add event listener to handle particle interaction on click
                this.canvas.addEventListener('mousemove', (event) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = event.clientX - rect.left;
                    const mouseY = event.clientY - rect.top;
                    const energy = 10000; // Energy to transfer on click

                    // Check for particles near mouse pointer and set them on fire
                    for (const particle of this.particles) {
                        const distance = Math.sqrt(
                            Math.pow(mouseX - particle.x, 2) + Math.pow(mouseY - particle.y, 2)
                        );
                        if (distance <= 5) {
                            // particle.onFire = true;
                            particle.applyHeat(energy)
                            // console.log(particle)

                        }
                        // else {
                        //     particle.onFire = false;
                        // }
                    }
                });
            }

            addParticle(x, y, substance) {
                // Create a new particle and add it to the system

                const particle = new Particle(x, y, substance);
                particle.particles = this.particles
                particle.i = this.particles.length
                this.particles.push(particle);

                return particle;
            }

            update() {
                // Update all particles in the system
                for (const particle of this.particles) {
                    particle.update(this.particles);
                }

                // Remove particles with zero energy
                this.particles = this.particles.filter((particle) => particle.energyContained > 0.1);
            }

            calculateOverallEnergy() {
                // Calculate the overall energy remaining in the branch
                let overallEnergy = 0;
                for (const particle of this.particles) {
                    overallEnergy += particle.energyContained;
                }
                return overallEnergy;
            }

            calculateAverageTemperature() {
                // Calculate the average temperature of all particles
                let totalTemperature = 0;
                for (const particle of this.particles) {
                    totalTemperature += particle.temperature;
                }
                return totalTemperature / this.particles.length;
            }

            render() {
                // Clear the canvas
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Render all particles in the system
                for (const particle of this.particles) {
                    particle.render(this.context);
                }

                // Update information div
                // const infoDiv = document.getElementById('info');
                // const overallEnergy = this.calculateOverallEnergy();
                // const averageTemperature = this.calculateAverageTemperature();
                // infoDiv.innerHTML = `Overall Energy: ${overallEnergy.toFixed(2)} | Average Temperature: ${averageTemperature.toFixed(2)}`;
            }

            startSimulation() {
                // Start the simulation loop
                const updateAndRender = () => {
                    this.update();
                    this.render();
                    requestAnimationFrame(updateAndRender);
                };
                updateAndRender();
            }

            init() {
                //CREATES PARTICLES OF WOOD
                for (let i = 0; i < 110; i++) {
                    for (let j = 0; j < 22; j++) {
                        let random1 = Math.random() * 0.1 + 0.95
                        let random2 = Math.random() * 0.1 + 0.95
                        const x = i * random1 + 300;
                        const y = 200 + j * random2
                        this.addParticle(x, y, 'wood');
                    }
                }
                for (let p of this.particles) {
                    for (let p2 of this.particles) {
                        if (p == p2) continue
                        const distance = Math.sqrt(
                            Math.pow(p.x - p2.x, 2) + Math.pow(p.y - p2.y, 2)
                        );
                        if (distance > 2) continue
                        p.nearParticles.push(p2)
                    }
                }
            }
        }


        // Usage example:
        const particleSystem = new ParticleSystem('canvas', 800, 600);
        particleSystem.init()

        particleSystem.startSimulation();
    </script>
</body>

</html>
