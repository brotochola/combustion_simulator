<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<script src="liquidfun.js"></script>
<!-- testbed code !-->
<script src="renderer.js"></script>
<script src="three.js"></script>

<style>
    body {
        height: 100vh;
        width: 100vw;
        background: #333;
        overflow: hidden;
        -webkit-filter: url('#filter') !important;
        filter: url('#filter') !important;
    }

    canvas {
        border: none !important;
        outline: none !important;
        height: 100vh !important;
        width: 100vw !important;
        position: absolute;
        top: 0;
        left: 0 !important;
        -webkit-filter: url('#filter') !important;
        filter: url('#filter') !important;
    }
</style>
<!--<script src="https://google.github.io/liquidfun/testbed/testbed/tests/testWaveMachine.js"></script>-->
<!--<canvas id="canvas" width="600" height="400" style="background-color:#333333;" ></canvas>-->

<body></body>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
    <defs>
        <filter id="filter">
            <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur" />
            <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 19 -9"
                result="filter" />
            <!-- 0.7 -1 1 0 1.3 0 -1 1 0 0 1 -1 1 -1 0 0 0 0 30 -5 -->
            <feComposite in="SourceGraphic" in2="filter" operator="atop" />
            <feBlend mode="darken" in="SourceGraphic" />

        </filter>
    </defs>
</svg>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
    <defs>
        <filter id="goo">
            <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur" />
            <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 19 -9" result="goo" />
            <feComposite in="SourceGraphic" in2="goo" operator="atop" />
        </filter>
    </defs>
</svg>

<script>
    // shouldnt be a global :(
    var particleColors = [
        new b2ParticleColor(0xff, 0x00, 0x00, 0xff), // red
        new b2ParticleColor(0x00, 0xff, 0x00, 0xff), // green
        new b2ParticleColor(0x00, 0x00, 0xff, 0xff), // blue
        new b2ParticleColor(0xff, 0x8c, 0x00, 0xff), // orange
        new b2ParticleColor(0x00, 0xce, 0xd1, 0xff), // turquoise
        new b2ParticleColor(0xff, 0x00, 0xff, 0xff), // magenta
        new b2ParticleColor(0xff, 0xd7, 0x00, 0xff), // gold
        new b2ParticleColor(0x00, 0xff, 0xff, 0xff) // cyan
    ];
    var container;
    var world = null;
    var threeRenderer;
    var renderer;
    var camera;
    var scene;
    var objects = [];
    var timeStep = 1.0 / 60.0;
    var velocityIterations = 8;
    var positionIterations = 3;
    var test = {};
    var projector = new THREE.Projector();
    var planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    var g_groundBody = null;

    var windowWidth = window.innerWidth;
    var windowHeight = window.innerHeight;

    function printErrorMsg(msg) {
        var domElement = document.createElement('div');
        domElement.style.textAlign = 'center';
        domElement.innerHTML = msg;
        document.body.appendChild(domElement);
    }

    function initTestbed() {
        camera = new THREE.PerspectiveCamera(70
            , windowWidth / windowHeight
            , 1, 1000);

        try {
            threeRenderer = new THREE.WebGLRenderer();
        } catch (error) {
            printErrorMsg('<p>Sorry, your browser does not support WebGL.</p>'
                + '<p>This testbed application uses WebGL to quickly draw'
                + ' LiquidFun particles.</p>'
                + '<p>LiquidFun can be used without WebGL, but unfortunately'
                + ' this testbed cannot.</p>'
                + '<p>Have a great day!</p>');
            return;
        }

        threeRenderer.setClearColor(0x333333);
        threeRenderer.setSize(windowWidth, windowHeight);

        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 100;
        scene = new THREE.Scene();
        camera.lookAt(scene.position);

        document.body.appendChild(this.threeRenderer.domElement);

        this.mouseJoint = null;

        // hack
        renderer = new Renderer();
        var gravity = new b2Vec2(0, -10);
        world = new b2World(gravity);
        Testbed();
    }

    function testSwitch(testName) {
        ResetWorld();
        world.SetGravity(new b2Vec2(0, -10));
        var bd = new b2BodyDef;
        g_groundBody = world.CreateBody(bd);
        test = new window[testName];
    }

    function Testbed(obj) {
        // Init world
        //GenerateOffsets();
        //Init
        var that = this;
        document.addEventListener('keypress', function (event) {
            if (test.Keyboard !== undefined) {
                test.Keyboard(String.fromCharCode(event.which));
            }
        });
        document.addEventListener('keyup', function (event) {
            if (test.KeyboardUp !== undefined) {
                test.KeyboardUp(String.fromCharCode(event.which));
            }
        });

        document.addEventListener('mousedown', function (event) {
            var p = getMouseCoords(event);
            var aabb = new b2AABB;
            var d = new b2Vec2;

            d.Set(0.01, 0.01);
            b2Vec2.Sub(aabb.lowerBound, p, d);
            b2Vec2.Add(aabb.upperBound, p, d);

            var queryCallback = new QueryCallback(p);
            world.QueryAABB(queryCallback, aabb);

            if (queryCallback.fixture) {
                var body = queryCallback.fixture.body;
                var md = new b2MouseJointDef;
                md.bodyA = g_groundBody;
                md.bodyB = body;
                md.target = p;
                md.maxForce = 1000 * body.GetMass();
                that.mouseJoint = world.CreateJoint(md);
                body.SetAwake(true);
            }
            if (test.MouseDown !== undefined) {
                test.MouseDown(p);
            }

        });

        document.addEventListener('mousemove', function (event) {
            var p = getMouseCoords(event);
            if (that.mouseJoint) {
                that.mouseJoint.SetTarget(p);
            }
            if (test.MouseMove !== undefined) {
                test.MouseMove(p);
            }
        });

        document.addEventListener('mouseup', function (event) {
            if (that.mouseJoint) {
                world.DestroyJoint(that.mouseJoint);
                that.mouseJoint = null;
            }
            if (test.MouseUp !== undefined) {
                test.MouseUp(getMouseCoords(event));
            }
        });


        window.addEventListener('resize', onWindowResize, false);

        // testSwitch("TestWaveMachine");

        render();
    }

    var render = function () {
        // bring objects into world
        renderer.currentVertex = 0;
        if (test.Step !== undefined) {
            test.Step();
        } else {
            Step();
        }
        renderer.draw();

        threeRenderer.render(scene, camera);
        requestAnimationFrame(render);
    };

    var ResetWorld = function () {
        if (world !== null) {
            while (world.joints.length > 0) {
                world.DestroyJoint(world.joints[0]);
            }

            while (world.bodies.length > 0) {
                world.DestroyBody(world.bodies[0]);
            }

            while (world.particleSystems.length > 0) {
                world.DestroyParticleSystem(world.particleSystems[0]);
            }
        }
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 100;
    };

    var Step = function () {
        world.Step(timeStep, velocityIterations, positionIterations);
    };

    /**@constructor*/
    function QueryCallback(point) {
        this.point = point;
        this.fixture = null;
    }

    /**@return bool*/
    QueryCallback.prototype.ReportFixture = function (fixture) {
        var body = fixture.body;
        if (body.GetType() === b2_dynamicBody) {
            var inside = fixture.TestPoint(this.point);
            if (inside) {
                this.fixture = fixture;
                return true;
            }
        }
        return false;
    };

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        //camera.updateProjectionMatrix();
        threeRenderer.setSize(window.innerWidth - '100', window.innerHeight);
    }

    function getMouseCoords(event) {
        var mouse = new THREE.Vector3();
        mouse.x = (event.clientX / windowWidth) * 2 - 1;
        mouse.y = -(event.clientY / windowHeight) * 2 + 1;
        mouse.z = 0.5;

        projector.unprojectVector(mouse, camera);
        var dir = mouse.sub(camera.position).normalize();
        var distance = -camera.position.z / dir.z;
        var pos = camera.position.clone().add(dir.multiplyScalar(distance));
        var p = new b2Vec2(pos.x, pos.y);
        return p;
    }








    document.body.onload = initTestbed();
    testSwitch('dale');


    function dale() {
        camera.position.y = 3;
        camera.position.z = 6;

        var bd = new b2BodyDef();
        var ground = world.CreateBody(bd);

        var shape1 = new b2PolygonShape();
        var vertices = shape1.vertices;
        vertices.push(new b2Vec2(-4, -1));
        vertices.push(new b2Vec2(4, -1));
        vertices.push(new b2Vec2(4, 0));
        vertices.push(new b2Vec2(-4, 0));
        ground.CreateFixtureFromShape(shape1, 0);

        var shape2 = new b2PolygonShape();
        var vertices = shape2.vertices;
        vertices.push(new b2Vec2(-4, -0.1));
        vertices.push(new b2Vec2(-2, -0.1));
        vertices.push(new b2Vec2(-2, 2));
        vertices.push(new b2Vec2(-4, 2));
        ground.CreateFixtureFromShape(shape2, 0);

        var shape3 = new b2PolygonShape();
        var vertices = shape3.vertices;
        vertices.push(new b2Vec2(2, -0.1));
        vertices.push(new b2Vec2(4, -0.1));
        vertices.push(new b2Vec2(4, 2));
        vertices.push(new b2Vec2(2, 2));
        ground.CreateFixtureFromShape(shape3, 0);

        var psd = new b2ParticleSystemDef();
        console.log("partycle system", psd)
        psd.powderStrength = 100000
        psd.springStrength = 999
        psd.lifetimeGranularity = 99
        psd.surfaceTensionNormalStrength = 99
        psd.surfaceTensionPressureStrength = 9999
        psd.viscousStrength = -9999
        psd.radius = 0.03;
        var particleSystem = world.CreateParticleSystem(psd);

        // one group
        var circle = new b2CircleShape();
        circle.position.Set(0, 7);
        circle.radius = 0.5;
        var pgd = new b2ParticleGroupDef();

        // pgd.groupFlags = b2_rigidParticleGroup | b2_solidParticleGroup;
        pgd.shape = circle;
        pgd.color.Set(255, 0, 0, 255);
        particleSystem.CreateParticleGroup(pgd);

        // two group
        circle = new b2CircleShape();
        circle.position.Set(-1, 3);
        circle.radius = 0.5;
        pgd = new b2ParticleGroupDef();
        // pgd.groupFlags = b2_springParticle | b2_solidParticleGroup;;
        pgd.flags = b2_elasticParticle;

        // console.log(pgd.flags)
        // pgd.groupFlags = b2_solidParticleGroup;

        pgd.shape = circle;
        pgd.color.Set(0, 255, 0, 255);
        particleSystem.CreateParticleGroup(pgd);

        // third group
        var box = new b2PolygonShape();
        var pgd = new b2ParticleGroupDef();
        box.SetAsBoxXY(1, 0.5);
        pgd.groupFlags = b2_rigidParticleGroup | b2_solidParticleGroup;;
        pgd.position.Set(1, 4);
        pgd.angle = -0.5;
        pgd.angularVelocity = 2;
        pgd.shape = box;
        pgd.color.Set(0, 0, 255, 255);
        particleSystem.CreateParticleGroup(pgd);


        // circle
        bd = new b2BodyDef()
        var circle = new b2CircleShape();
        bd.type = b2_dynamicBody;
        var body = world.CreateBody(bd);
        circle.position.Set(0, 8);
        circle.radius = 0.5;
        body.CreateFixtureFromShape(circle, 0.5);
    }


</script>